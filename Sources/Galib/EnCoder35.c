/**************************文件说明*****************************************************
* Copyright (c) 2019 ,杭州广安汽车电器有限公司  All rights reserved.
*
* 文件名称：Encoder35.c
* 功能描述：35编码器读取模块，具有如下功能
* 1 通过读取 35编码器 3个PIN的状态值，得到命令并将命令放入队列模块
* 2 用户通过队列模块读取命令
* 
* 编译器： codewarrior IDE 10.7-KEAZ128
* MCU说明：此文件跟MCU无关
* 
* */
/**************************更改记录******************************************************
 * 
* 版本：1.0
* 说明：初始版本建立， 从原模块的1.1移植
* 原作者：xb
* 完成日期：2019年7月3日
* 
*/

#include "EnCoder35.h"
#include "ComdQueue.h"

typedef struct
{
   uint8 CodeCur ;  //当前的状态
   uint8 CodeOld;  //上一次的状态
   uint8 CodeErr;
   uint8 KeyCode;
}CODE35DATA;    //定义数据结构


static CODE35DATA Code35Data[MAX_CODE35NUM];
static uint8 CodeTotalNum = 0;



//需要从外部调用的函数声明
//返回编码器的值 三个脚 abc。 对应返回字 0位，1位 ，2位的状态
extern uint8 Code35HW_ReadPin(uint8 num);

 /*******************************************************************************
 * Function:   BOOL Init_Code35（uint8 num ,uint8 *CodeKeyData)
 *
 * Description:  编码器1控制初始化,  
 *               CodeKeyData 数组(大小为3) 为编码器键值(左边的)编号，右边的键值默认为左边的--，
 *               如果错误则设置为0（无效）
 *
 * Returns:      TRUE 设置正确, FALSE 设置错误
 *
 * Notes:      编码器初始化
 *
*******************************************************************************/
 BOOL Init_Code35(uint8 num ,uint8 *CodeKeyData)
 {
	CODE35DATA *pCodeData = Code35Data;
	BOOL bInitCode35;
	if(num == 0 || num > MAX_CODE35NUM) 
	{
		bInitCode35 = FALSE;
	}
	else
	{
		bInitCode35 = TRUE;
		CodeTotalNum = num;
    
		for(num=0; num < CodeTotalNum; num++)
		{
			if(CodeKeyData[num] != 0) 
			{
				pCodeData->KeyCode = CodeKeyData[num];
				pCodeData->CodeErr = CODE35_ERROR_NONE;
			}
			else
			{
				pCodeData->KeyCode = 0;
				pCodeData->CodeErr = CODE35_ERROR_KEYCODE;
			}
			pCodeData++;
		}
		bInitCode35 = TRUE;
	}
	
	return bInitCode35;
}
 /*******************************************************************************
 * Function:  void Treat_Read_Code35(void)
 *
 * Description: 编码器35控制
 *
 * Returns:     none
 *
 * Notes:    该函数仅被main函数循环调用,必须为4ms以上的频率，否则放在中断位置 		
 *
*******************************************************************************/
void Treat_Read_Code35(void)
{
	//读取风档开关电平
	uint8 num ;
	uint8 KeyCode = 0; // 1 ++ ,2--
	CODE35DATA *pCodeData = Code35Data;
	
	for (num = 0; num < CodeTotalNum; num++)
	{
		pCodeData->CodeCur = Code35HW_ReadPin(num);  //从硬件模块中读取当前的端口状态
      
      if (pCodeData->CodeCur != pCodeData->CodeOld && pCodeData->CodeCur != 0x07)
      {
      	//不一样键值时需要处理
      	switch(pCodeData->CodeOld)
      	{
      		default:
      			pCodeData->CodeErr |= CODE35_ERROR_HARDWARE;
               break;
            case  0b00000011:
               if(pCodeData->CodeCur == 0b00000101)
   				{
   					KeyCode = 1;
   				}
   				else if (pCodeData->CodeCur == 0b00000110)
   				{
   					KeyCode =2;
   				}
   				else{}
   				break;
            case  0b00000101:
               if (pCodeData->CodeCur == 0b00000110)
               {
                  KeyCode = 1;
               }
               else if(pCodeData->CodeCur == 0b00000011)
               {
               	KeyCode =2;
               } 
               else
               {
               }
               break;
            case  0b00000110:
               if (pCodeData->CodeCur == 0b00000011)
               {
                  KeyCode = 1;
               }
               else if (pCodeData->CodeCur == 0b00000101)
               {
                  KeyCode = 2;
               }
               else{}
               break; 
         }
         if (KeyCode == 1) 
         {  //清故障码
         	pCodeData->CodeErr &= ~CODE35_ERROR_HARDWARE;  
         	(void)InsertComd(pCodeData->KeyCode);
         }
         else if(KeyCode == 2)
         {
         	pCodeData->CodeErr &= ~CODE35_ERROR_HARDWARE;  
         	(void)InsertComd(pCodeData->KeyCode - 1);
         }
         else{}
         
         pCodeData->CodeOld = pCodeData->CodeCur;
      //不一样键值时需要处理
      }
      pCodeData++;
	}
}








